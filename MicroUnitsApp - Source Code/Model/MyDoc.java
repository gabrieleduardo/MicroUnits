/**
 * MicroUnits - Pauses Analysis of XML files generated by Translog II software.
 * For Translog II details See <http://bridge.cbs.dk/platform/?q=Translog-II>
 *
 * Copyright (C) 2014 Gabriel Ed. da Silva
 *
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Affero General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more
 * details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
package Model;

import static Model.StringTreatment.format2f;
import java.util.ArrayList;

/**
 *
 * @author Gabriel Ed
 */
public class MyDoc {

    private String path;

    private final ArrayList<Fix> fixWin1;

    private final ArrayList<Fix> fixWin2;

    private final ArrayList<Fix> fixList;

    private ArrayList<Key> keys;

    private Integer finalTime;

    private final Integer[] ifix;
    
    private Integer globalfix;

    /**
     * Class constructor
     * Construtor de Classe
     *
     * @param path - File path
     */
    public MyDoc(String path) {
        this.path = path;
        fixWin1 = new ArrayList<>();
        fixWin2 = new ArrayList<>();
        fixList = new ArrayList<>();
        keys = new ArrayList<>();
        finalTime = 0;
        ifix = new Integer[2];
        for (int i = 0; i < ifix.length; i++) {
            ifix[i] = 0;
        }
        globalfix = 0;
    }

    /**
     * Add a fix object into Fixation Windows List
     * Adiciona um objeto fix na lista de fixação de janelas
     *
     * @param fix Fix Object
     */
    public void addfixationWin(Fix fix) {
        Integer i = fix.getWin();
        getfixationWin(i).add(fix);
    }
    
    /**
     * Add a fix object into fixation list
     * Adiciona um objeto fix na lista de fixações
     *
     * @param fix Fix Object
     */
    
    public void addFixList(Fix fix){
        fixList.add(fix);
    }
    
    /**
     *  Get a fix in fixList
     *  Recupera uma fixação da lista
     * 
     * @param i Index
     * @return Fix
     */
    public Fix getfixList(Integer i){
        return fixList.get(i);
    }

    /**
     * Add a Key Object into Key List
     * Adiciona um objeto Key na lista de Keys.
     *
     * @param key Key Object
     */
    public void addKey(Key key) {
        getKeys().add(key);
    }

    /**
     * Fixation Pause Analysis
     * Analisador de Pausas para Fixação
     *
     * @param pause Time between pauses
     * @return ArrayList with the fix values
     * @throws java.lang.Exception Exception
     */
    public ArrayList<String> pausefixationAnalysis(Integer pause) throws Exception {

        ArrayList<Integer> pausesVector = new ArrayList<>();
        ArrayList<Integer> charactersVector = new ArrayList<>();
        ArrayList<String> stringList = new ArrayList<>();
        Integer TI;
        Integer TF;
        Boolean aux = true;
        Integer dif;
        Integer chars = 0;
        resetIfix();
        stringList.add(getPath());
        TF = getKeys().get(0).getTime(); // First Key Time

        /**
         * Fixations before the first Key
         * Fixações antes do primeiro uso de tecla
         */
        stringList.add("\nFixation before the first Key: \n");
        stringList.addAll(stFixation(TF));
        stringList.add("\n\n");
        TI = TF;

        for (int i = 0; i < getKeys().size() - 1; i++) {

            /**
             * Add the start time of a segment
             * Adiciona um tempo de inicio ao segmento
             */
            if (aux) {
                stringList.add("(" + TI + ")");
                aux = false;
            }

            /**
             * Calculates the time between the Keys N and N+1
             * Calcula o tempo entre as teclas N e N+1.
             */
            dif = getKeys().get(i + 1).getTime() - getKeys().get(i).getTime();

            /**
             * Count the number of chars typed in the segment
             * Conta o número de caracteres acionados no segmento
             */
            chars += charactersCount(getKeys().get(i).getValue());

            if (dif >= pause) {
                TF = getKeys().get(i + 1).getTime();
                pausesVector.add(dif);
                charactersVector.add(chars);
                chars = 0;
                stringList.add(getKeys().get(i).getValue());
                stringList.add("(" + TF + ")");
                stringList.add("\n");
                stringList.addAll(stFixation(TF));
                stringList.add("\n\n");
                TI = TF;
                aux = true;
            } else {
                stringList.add(getKeys().get(i).getValue());
            }
        }

        /**
         * Checks the last element and calculates the difference between 
         * your time and the stop time
         * 
         * Verifica o último elemento e calcula a diferença entre seu tempo e o
         * tempo de término.
         */
        TI = TF;
        TF = getFinalTime();
        int i = getKeys().size() - 1;
        dif = getFinalTime() - getKeys().get(i).getTime();
        chars += charactersCount(getKeys().get(i).getValue());
        pausesVector.add(dif);
        charactersVector.add(chars);

        if (dif >= pause) {
            stringList.add("(" + TI + ")");
            stringList.add(getKeys().get(i).getValue());
            stringList.add("(" + TF + ")");
            stringList.add("\n");
            stringList.addAll(stFixation(TF));
            stringList.add("\n\n");

        } else {
            stringList.add(getKeys().get(i).getValue());
            stringList.add("(" + TF + ")" + "\n" + stFixation(TF));
        }

        stringList.add("\n\n###Statistics###\n");
        stringList.add(statisticString(pausesVector, getFinalTime(), pause));
        stringList.add(statisticStringChars(charactersVector, pause));
        stringList.add("\n#########################\n\n");

        return stringList;
    }

    /**
     * Key pauses analysis
     * Análise de teclas de pausa
     *
     * @param pause Time between pauses
     * @return ArrayLis with the pauses values
     * @throws java.lang.Exception - Exception
     */
    public ArrayList<String> pauseAnalysis(Integer pause) throws Exception {

        if (getKeys() == null) {
            return null;
        }

        ArrayList<Integer> pausesVector = new ArrayList<>();
        ArrayList<Integer> charactersVector = new ArrayList<>();
        ArrayList<String> stringList = new ArrayList<>();

        stringList.add(getPath());
        stringList.add("(" + getKeys().get(0).getTime() + ")");
        Integer dif;
        Integer chars = 0;
        int i;

        for (i = 0; i < getKeys().size() - 1; i++) {
            
            /**
             * Calculates the time between the Keys N and N+1
             * Calcula a diferença entre as Keys n e N+1
             */
            dif = getKeys().get(i + 1).getTime() - getKeys().get(i).getTime();

            
            /**
             * Count the number of chars typed in the segment
             * Conta a quantidade de caracteres digitados em cada segmentos
             */
            chars += charactersCount(getKeys().get(i).getValue());

            if (dif >= pause) {
                pausesVector.add(dif);
                charactersVector.add(chars);
                chars = 0;
                stringList.add(getKeys().get(i).getValue());
                stringList.add("(" + dif + ")");
            } else {
                stringList.add(getKeys().get(i).getValue());
            }
        }

        /**
         * Checks the last element and calculates the difference between 
         * your time and the stop time
         * 
         * Verifica o último elemento e calcula a diferença entre seu tempo e 
         * o tempo final.
         */
        dif = getFinalTime() - getKeys().get(i).getTime();
        chars += charactersCount(getKeys().get(i).getValue());
        pausesVector.add(dif);

        if (dif >= pause) {
            stringList.add(getKeys().get(i).getValue());
            stringList.add("(" + dif + ")");
        } else {
            stringList.add(getKeys().get(i).getValue());
        }
        stringList.add("\n###Statistics###\n");
        stringList.add(statisticString(pausesVector, getFinalTime(), pause));
        stringList.add(statisticStringChars(charactersVector, pause));
        stringList.add("\n#########################");

        return stringList;
    }

    /**
     * Fixation checks for Win = 1 and Win = 2
     * Verifica as fixações para Win = 1 e Win = 2
     */
    private ArrayList<String> stFixation(Integer TF) {
        
        ArrayList<String> retorno = new ArrayList<>();
        for (int i = 1; i < 3; i++) {
            retorno.add(stFixation(TF, i));
        }
        
        retorno.add(transitionsCounts(TF));

        return retorno;
    }

    /**
     * Fixation checks during the last segment break
     * Verificação de fixação durante o ultimo segmento.
     */
    private String stFixation(Integer TF, Integer win) {
        if (ifix[win - 1] >= getfixationWin(win).size()) {
            return "";
        }

        Integer aux = win - 1;
        Integer ac = 0;
        Integer sum = 0;
        Integer decrement = getfixationWin(win).get(ifix[aux]).getTime();

        while (ifix[aux] < getfixationWin(win).size() && getfixationWin(win).get(ifix[aux]).getTime() <= TF) {
            ac++;
            sum += getfixationWin(win).get(ifix[aux]).getTime() - decrement;
            decrement = getfixationWin(win).get(ifix[aux]).getTime();
            ifix[aux]++;
        }

        if (ac > 0) {
            return "[Win=" + win + "] Fixation Number: " + ac + " // Average Fixation Duration: " + (sum / ac) + " ms // Fixation Duration: " + sum + "\n";
        } else {
            return "[Win=" + win + "] There are no fixations in this segment \n";
        }
    }
    
    /**
     * Calculates the transitions between Windows
     * Calcula o número de transições entre as janelas
     * 
     * @param TF Segment End time
     * @return The number os transitions
     */
    private String transitionsCounts(Integer TF){
        if (globalfix >= fixList.size()) {
            return "";
        }
        
        Integer transitions = 0;
        Boolean aux = false;
        
        if(globalfix - 1 >= 0){
            aux = true;
        }

        
        while (globalfix < fixList.size() && fixList.get(globalfix).getTime() <= TF) {
            if(aux && fixList.get(globalfix-1) != fixList.get(globalfix)){
                transitions++;
            }
            
            globalfix++;
        }
        
        return "Total transitions between windows: "+transitions+"\n";
    }

    /**
     * Counts the number of characters in a string. 
     * If it be a commando will be counted like 1.
     * 
     * Conta o número de caracteres presentes em uma string.
     * Caso seja um comando é considerado como um caractere.
     * 
     * @param st String
     * @return Number os chars of the String
     */
    private static Integer charactersCount(String st) {
        if (st == null) {
            return 0;
        } else if (st.startsWith("[")) {
            return 1;
        } else {
            return st.length();
        }
    }
    
    /**
     * Calculates the average, standard deviation, min and max characters between pauses.
     * Calcula a média, desvio padrão, min e máximo de caracteres entre pausas.
     * 
     * @param v Integer ArrayList with the numbers os characters
     * @param pause Pause value
     * @return String with the data
     */
    private static String statisticStringChars(ArrayList<Integer> v, Integer pause) {
        Statistic statistic = new Statistic<>();
        Double average = statistic.average(v);
        Double standardDeviation = statistic.standardDeviation(v, average);
        Double max = statistic.max(v);
        Double min = statistic.min(v);

        String returnValue = "\nAverage number of characters between pauses longer than or equal to " + pause + ": " + format2f(average) + "\n"
                + "Standard deviation of characters between pauses longer than or equal to " + pause + ": " + format2f(standardDeviation) + "\n"
                + "Min Standard deviation of characters between pauses longer than or equal to " + pause + ": " + format2f(min) + "\n"
                + "Max Standard deviation of characters between pauses longer than or equal to " + pause + ": " + format2f(max) + "\n";

        return returnValue;

    }
    
    /**
     * Calculates the average, standard deviation, min and max values between pauses.
     * Calcula a média, desvio padrão, min e max valores entre pausas
     * @param v ArrayList with the values
     * @param finalTime Stop time
     * @param pause Pause Value
     * @return String with the data
     */
    private static String statisticString(ArrayList<Integer> v, Integer finalTime, Integer pause) {
        Statistic statistic = new Statistic<>();
        Double average = statistic.average(v);
        Double standardDeviation = statistic.standardDeviation(v, average);
        Double max = statistic.max(v);
        Double min = statistic.min(v);
        

        String returnValue = "Task duration: " + finalTime + " \n" + ""
                + "Average duration of pauses longer than or equal to " + pause + ": " + format2f(average) + "\n"
                + "Standard Deviation of pauses longer than or equal to " + pause + ": " + format2f(standardDeviation) + "\n"
                + "Min value of pauses longer than or equal to " + pause + ": " + format2f(min) + "\n"
                + "Max value of pauses longer than or equal to " + pause + ": " + format2f(max) + "\n";

        return returnValue;

    }

    /**
     * Get the Path
     * Recupera o caminho
     * 
     * @return the path
     */
    public String getPath() {
        return path;
    }

    /**
     * Set the path
     * Atualiza o caminho
     * 
     * @param path the path to set
     */
    public void setPath(String path) {
        this.path = path;
    }

    /**
     * Gets the selected fixation window list
     * Recupera a lista das fixações na janela desejada
     * @param i - Win value
     * @return the fix
     */
    public ArrayList<Fix> getfixationWin(Integer i) {
        switch (i) {
            case 1:
                return fixWin1;
            case 2:
                return fixWin2;
            default:
                return null;
        }
    }

    /**
     * Gets the Key List
     * Recupera uma lista de Key
     * 
     * @return the keys
     */
    public ArrayList<Key> getKeys() {
        return keys;
    }

    /**
     * Set the Key List
     * Atualiza a lista de Key
     * 
     * @param keys the keys to set
     */
    private void setKeys(ArrayList<Key> keys) {
        this.keys = keys;
    }

    /**
     * Gets the final time
     * Recupera o tempo final
     * @return the finalTime
     */
    public Integer getFinalTime() {
        return finalTime;
    }

    /**
     * Set the final time
     * Atualiza o tempo final
     * 
     * @param finalTime the finalTime to set
     */
    public void setFinalTime(Integer finalTime) {
        this.finalTime = finalTime;
    }

    /**
     * Resets the ifix field
     * Reseta o campo iFix
     */
    private void resetIfix() {
        for (int i = 0; i < ifix.length; i++) {
            ifix[i] = 0;
        }
    }
}
