/**
 * MicroUnits - Pauses Analysis in XML files generated by Translog II software.
 * For Translog II details See <http://bridge.cbs.dk/platform/?q=Translog-II>
 *
 * Copyright (C) 2014 Gabriel Ed. da Silva
 *
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Affero General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more
 * details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

package MicroUnits;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

/**
 *
 * @author Gabriel Ed
 */
public class Parse {

    //Expressões
    /**
     * Expressão para recuperar os valores de Key
     */
    public static final String expressionKey = "//Key";

    /**
     * Expressão utilizada para recuperar o tempo final.
     */
    public static final String expressionTempoFinal = "//System[@Value='STOP']";

    //Objetos
    /**
     * Retorna o tempo final de um arquivo Translog.XML
     *
     * @param path - Endereço do Arquivo XML
     * @return
     */
    public static Integer parseTempoFinal(String path) {

        try {
            //Variáveis
            Integer retorno;
            NodeList nodeList;

            // Parse do Documento XML
            FileInputStream file = null;
            file = new FileInputStream(new File(path));

            DocumentBuilderFactory builderFactory = DocumentBuilderFactory.newInstance();

            DocumentBuilder builder = null;
            builder = builderFactory.newDocumentBuilder();

            org.w3c.dom.Document xmlDocument;
            xmlDocument = builder.parse(file);

            XPath xPath = XPathFactory.newInstance().newXPath();

            nodeList = (NodeList) xPath.compile(expressionTempoFinal).evaluate(xmlDocument, XPathConstants.NODESET);
            retorno = Integer.parseInt(nodeList.item(0).getAttributes().getNamedItem("Time").getNodeValue());

            return retorno;
        } catch (ParserConfigurationException | SAXException | XPathExpressionException ex) {
            Logger.getLogger(Parse.class.getName()).log(Level.SEVERE, null, ex);
        } catch (FileNotFoundException ex) {
            Logger.getLogger(Parse.class.getName()).log(Level.SEVERE, null, ex);
        } catch (IOException ex) {
            Logger.getLogger(Parse.class.getName()).log(Level.SEVERE, null, ex);
        }

        return null;
    }

    /**
     * Recupera todos os campos Key em um arquivo Translog.XML
     * @param path - Endereço do Arquivo XML
     * @return
     */
    public static ArrayList<Key> parseKeys(String path){
        try{
        //Variáveis
        ArrayList<Key> retorno = new ArrayList<>();
        String value;
        Integer time;
        NodeList nodeList;

        // Parse do Documento XML
        FileInputStream file = new FileInputStream(new File(path));

        DocumentBuilderFactory builderFactory = DocumentBuilderFactory.newInstance();

        DocumentBuilder builder = builderFactory.newDocumentBuilder();

        org.w3c.dom.Document xmlDocument = builder.parse(file);

        XPath xPath = XPathFactory.newInstance().newXPath();

        // Capturando Keys
        nodeList = (NodeList) xPath.compile(expressionKey).evaluate(xmlDocument, XPathConstants.NODESET);

        for (int i = 0; i < nodeList.getLength(); i++) {
            time = Integer.parseInt(nodeList.item(i).getAttributes().getNamedItem("Time").getNodeValue());
            value = nodeList.item(i).getAttributes().getNamedItem("Value").getNodeValue();
            retorno.add(new Key(time, value));
        }

        return retorno;
        } catch (XPathExpressionException | SAXException | IOException | ParserConfigurationException ex) {
            Logger.getLogger(Parse.class.getName()).log(Level.SEVERE, null, ex);
        }
        
        return null;
    }
}
