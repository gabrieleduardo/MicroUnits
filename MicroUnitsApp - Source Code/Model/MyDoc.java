/**
 * MicroUnits - Pauses Analysis of XML files generated by Translog II software.
 * For Translog II details See <http://bridge.cbs.dk/platform/?q=Translog-II>
 *
 * Copyright (C) 2014 Gabriel Ed. da Silva
 *
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Affero General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more
 * details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
package Model;

import java.util.ArrayList;

/**
 *
 * @author Gabriel Ed
 */
public class MyDoc {

    private String path;

    private ArrayList<Fix> fixWin1;

    private ArrayList<Fix> fixWin2;

    private ArrayList<Key> keys;

    private Integer finalTime;

    private Integer[] ifix;

    /**
     * Class constructor
     *
     * @param path - File path
     */
    public MyDoc(String path) {
        this.path = path;
        fixWin1 = new ArrayList<>();
        fixWin2 = new ArrayList<>();
        keys = new ArrayList<>();
        finalTime = 0;
        ifix = new Integer[2];
        for(int i = 0; i < ifix.length;i++){
            ifix[i] = 0;
        }
    }

    /**
     * Add a fix object
     *
     * @param fix - Fix Object
     */
    public void addfixationWin(Fix fix) {
        Integer i = fix.getWin();
        getfixationWin(i).add(fix);
    }

    /**
     * Add a key field
     *
     * @param key - Key Object
     */
    public void addKey(Key key) {
        getKeys().add(key);
    }

    /**
     * fixation Pause Analysis
     *
     * @param pause - Time between pauses
     * @return ArrayList with the fix values
     * @throws java.lang.Exception - Exception
     */
    public ArrayList<String> pausefixationAnalysis(Integer pause) throws Exception {

        ArrayList<Integer> pausesVector = new ArrayList<>();
        ArrayList<Integer> charactersVector = new ArrayList<>();
        ArrayList<String> stringList = new ArrayList<>();
        Integer TI;
        Integer TF;
        Boolean aux = true;
        Integer dif;
        Integer chars = 0;
        resetIfix();
        stringList.add(getPath());
        TF = getKeys().get(0).getTime(); // First Key Time

        //fixation before the first Key
        stringList.add("\nFixation before the first Key: \n");
        stringList.addAll(stFixation(TF));
        stringList.add("\n\n");
        TI = TF;

        for (int i = 0; i < getKeys().size() - 1; i++) {

            // Add the start time of a segment
            if (aux) {
                stringList.add("(" + TI + ")");
                aux = false;
            }

            // Calculates the time between the Keys N and N+1
            dif = getKeys().get(i + 1).getTime() - getKeys().get(i).getTime();

            // Count the number of chars typed in the segment
            chars += charactersCount(getKeys().get(i).getValue());

            if (dif >= pause) {
                TF = getKeys().get(i + 1).getTime();
                pausesVector.add(dif);
                charactersVector.add(chars);
                chars = 0;
                stringList.add(getKeys().get(i).getValue());
                stringList.add("(" + TF + ")");
                stringList.add("\n");
                stringList.addAll(stFixation(TF));
                stringList.add("\n\n");
                TI = TF;
                aux = true;
            } else {
                stringList.add(getKeys().get(i).getValue());
            }
        }

        /*
         * Checks the last element and calculates the difference between 
         * your time and the stop time
         */
        TI = TF;
        TF = getFinalTime();
        int i = getKeys().size() - 1;
        dif = getFinalTime() - getKeys().get(i).getTime();
        chars += charactersCount(getKeys().get(i).getValue());
        pausesVector.add(dif);
        charactersVector.add(chars);

        if (dif >= pause) {
            stringList.add("(" + TI + ")");
            stringList.add(getKeys().get(i).getValue());
            stringList.add("(" + TF + ")");
            stringList.add("\n");
            stringList.addAll(stFixation(TF));
            stringList.add("\n\n");

        } else {
            stringList.add(getKeys().get(i).getValue());
            stringList.add("(" + TF + ")" + "\n" + stFixation(TF));
        }

        stringList.add("\n\n###Statistics###\n");
        stringList.add(statisticString(pausesVector, getFinalTime(), pause));
        stringList.add(statisticStringCharsChars(charactersVector, pause));
        stringList.add("\n#########################\n\n");

        return stringList;
    }

    /**
     * Key pauses analysis
     *
     * @param pause - Time between pauses
     * @return ArrayLis with the pauses values
     * @throws java.lang.Exception - Exception
     */
    public ArrayList<String> pauseAnalysis(Integer pause) throws Exception {

        if (getKeys() == null) {
            return null;
        }

        ArrayList<Integer> pausesVector = new ArrayList<>();
        ArrayList<Integer> charactersVector = new ArrayList<>();
        ArrayList<String> stringList = new ArrayList<>();

        stringList.add(getPath());
        stringList.add("(" + getKeys().get(0).getTime() + ")");
        Integer dif;
        Integer chars = 0;
        int i;

        for (i = 0; i < getKeys().size() - 1; i++) {
            // Calculates the time between the Keys N and N+1
            dif = getKeys().get(i + 1).getTime() - getKeys().get(i).getTime();

            // Count the number of chars typed in the segment
            chars += charactersCount(getKeys().get(i).getValue());

            if (dif >= pause) {
                pausesVector.add(dif);
                charactersVector.add(chars);
                chars = 0;
                stringList.add(getKeys().get(i).getValue());
                stringList.add("(" + dif + ")");
            } else {
                stringList.add(getKeys().get(i).getValue());
            }
        }

        /*
         * Checks the last element and calculates the difference between 
         * your time and the stop time
         */
        dif = getFinalTime() - getKeys().get(i).getTime();
        chars += charactersCount(getKeys().get(i).getValue());
        pausesVector.add(dif);

        if (dif >= pause) {
            stringList.add(getKeys().get(i).getValue());
            stringList.add("(" + dif + ")");
        } else {
            stringList.add(getKeys().get(i).getValue());
        }
        stringList.add("\n###Statistics###\n");
        stringList.add(statisticString(pausesVector, getFinalTime(), pause));
        stringList.add(statisticStringCharsChars(charactersVector, pause));
        stringList.add("\n#########################");

        return stringList;
    }

    private ArrayList<String> stFixation(Integer TF) {
        ArrayList<String> retorno = new ArrayList<>();
        for(int i = 1; i < 3;i++){
            retorno.add(stFixation(TF,i));
        }
        
        return retorno;
    }

    /*
     * fixation checks during the last segment break.
     */
    private String stFixation(Integer TF, Integer win) {
        if (ifix[win-1] >= getfixationWin(win).size()) {
            return "";
        }
        Integer ac = 0;
        Integer sum = 0;
        Integer decrement = getfixationWin(win).get(ifix[win-1]).getTime();

        while (ifix[win-1] < getfixationWin(win).size() && getfixationWin(win).get(ifix[win-1]).getTime() <= TF) {
            ac++;
            sum += getfixationWin(win).get(ifix[win-1]).getTime() - decrement;
            decrement = getfixationWin(win).get(ifix[win-1]).getTime();
            ifix[win-1]++;
        }

        if (ac > 0) {
            return "[Win="+win+"] Fixation Number: " + ac + " // Average Fixation Duration: " + (sum / ac) + " ms // Fixation Duration: " + sum+"\n";
        } else {
            return "[Win="+win+"] There are no fixations in this segment \n";
        }
    }

    /*
     * Counts the number of characters in a string. 
     * If it be a commando will be counted like 1.
     */
    private static Integer charactersCount(String st) {
        if (st == null) {
            return 0;
        } else if (st.startsWith("[")) {
            return 1;
        } else {
            return st.length();
        }
    }

    /*
     * Calculates the average, standard deviation, min and max characters between pauses.
     * Returns a string with the data.
     */
    private static String statisticStringCharsChars(ArrayList<Integer> v, Integer pause) {
        Statistic statistic = new Statistic<>();
        Double average = statistic.average(v);
        Double standardDeviation = statistic.standardDeviation(v, average);
        Double max = statistic.max(v);
        Double min = statistic.min(v);

        String returnValue = "\nAverage of characters between pauses longer than or equal to " + pause + ": " + format2f(average) + "\n"
                + "Standard deviation of characters between pauses longer than or equal to " + pause + ": " + format2f(standardDeviation) + "\n"
                + "Min Standard deviation of characters between pauses longer than or equal to " + pause + ": " + format2f(min) + "\n"
                + "Max Standard deviation of characters between pauses longer than or equal to " + pause + ": " + format2f(max) + "\n";

        return returnValue;

    }

    /*
     * Calculates the average, standard deviation, min and max characters between pauses.
     * Returns a string with the data.
     */
    private static String statisticString(ArrayList<Integer> v, Integer finalTime, Integer pause) {
        Statistic statistic = new Statistic<>();
        Double average = statistic.average(v);
        Double standardDeviation = statistic.standardDeviation(v, average);
        Double max = statistic.max(v);
        Double min = statistic.min(v);

        String returnValue = "Task duration: " + finalTime + " \n" + ""
                + "Average of pauses longer than or equal to " + pause + ": " + format2f(average) + "\n"
                + "Standard Deviation of pauses longer than or equal to " + pause + ": " + format2f(standardDeviation) + "\n"
                + "Min value of pauses longer than or equal to " + pause + ": " + format2f(min) + "\n"
                + "Max value of pauses longer than or equal to " + pause + ": " + format2f(max) + "\n";

        return returnValue;

    }

    private static String format2f(Number n) {
        return String.format("%.2f", n);
    }

    /**
     * @return the path
     */
    public String getPath() {
        return path;
    }

    /**
     * @param path the path to set
     */
    public void setPath(String path) {
        this.path = path;
    }

    /**
     * @param i - Win value
     * @return the fix
     */
    public ArrayList<Fix> getfixationWin(Integer i) {
        switch (i) {
            case 1:
                return fixWin1;
            case 2:
                return fixWin2;
            default:
                return null;
        }
    }

    /**
     * @return the keys
     */
    public ArrayList<Key> getKeys() {
        return keys;
    }

    /**
     * @param keys the keys to set
     */
    public void setKeys(ArrayList<Key> keys) {
        this.keys = keys;
    }

    /**
     * @return the finalTime
     */
    public Integer getFinalTime() {
        return finalTime;
    }

    /**
     * @param finalTime the finalTime to set
     */
    public void setFinalTime(Integer finalTime) {
        this.finalTime = finalTime;
    }

    private void resetIfix() {
        for(int i = 0; i < ifix.length;i++){
            ifix[i] = 0;
        }
    }
}
