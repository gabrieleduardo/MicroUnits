/**
 * MicroUnits - Pauses Analysis of XML files generated by Translog II software.
 * For Translog II details See <http://bridge.cbs.dk/platform/?q=Translog-II>
 *
 * Copyright (C) 2014 Gabriel Ed. da Silva
 *
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Affero General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more
 * details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
package Model;

import java.util.ArrayList;

/**
 *
 * @author Gabriel Ed
 */
public class MyDoc {

    private String path;

    private ArrayList<Integer> fix;

    private ArrayList<Key> keys;

    private Integer finalTime;

    private Integer ifix;

    /**
     * Class constructor
     *
     * @param path - File path
     */
    public MyDoc(String path) {
        this.path = path;
        fix = new ArrayList<>();
        keys = new ArrayList<>();
        finalTime = 0;
        ifix = 0;
    }

    /**
     * Add a fix field
     *
     * @param i - fixation time
     */
    public void addfixation(Integer i) {
        getfixation().add(i);
    }

    /**
     * Add a key field
     *
     * @param key - Key Object
     */
    public void addKey(Key key) {
        getKeys().add(key);
    }

    /**
     * fixation Pause Analysis 
     *
     * @param pause - Time between pauses
     * @return ArrayList with the fix values
     * @throws java.lang.Exception - Exception
     */
    public ArrayList<String> pausefixationAnalysis(Integer pause) throws Exception {

        if (getKeys() == null || getFinalTime() == null || getfixation() == null) {
            return null;
        }

        ArrayList<Integer> pausesVector = new ArrayList<>();
        ArrayList<Integer> charactersVector = new ArrayList<>();
        ArrayList<String> stringList = new ArrayList<>();
        Integer TI;
        Integer TF;
        Boolean aux = true;
        Integer dif;
        Integer chars = 0;
        this.setIfix((Integer) 0);

        stringList.add(getPath());
        TF = getKeys().get(0).getTime(); // First Key Time

        //fixation before the first Key
        stringList.add("\nFixation before the first Key: \n");
        stringList.add(stFixation(TF));
        stringList.add("\n\n");
        TI = TF;

        for (int i = 0; i < getKeys().size() - 1; i++) {

            // Add the start time of a segment
            if (aux) {
                stringList.add("(" + TI + ")");
                aux = false;
            }

            // Calculates the time between the Keys N and N+1
            dif = getKeys().get(i + 1).getTime() - getKeys().get(i).getTime();
            
            // Count the number of chars typed in the segment
            chars += charactersCount(getKeys().get(i).getValue());

            if (dif >= pause) {
                TF = getKeys().get(i + 1).getTime();
                pausesVector.add(dif);
                charactersVector.add(chars);
                chars = 0;
                stringList.add(getKeys().get(i).getValue());
                stringList.add("(" + TF + ")");
                stringList.add("\n");
                stringList.add(stFixation(TF));
                stringList.add("\n\n");
                TI = TF;
                aux = true;
            } else {
                stringList.add(getKeys().get(i).getValue());
            }
        }

        /*
         * Checks the last element and calculates the difference between 
         * your time and the stop time
         */
        TI = TF;
        TF = getFinalTime();
        int i = getKeys().size() - 1;
        dif = getFinalTime() - getKeys().get(i).getTime();
        chars += charactersCount(getKeys().get(i).getValue());
        pausesVector.add(dif);
        charactersVector.add(chars);

        if (dif >= pause) {
            stringList.add("(" + TI + ")");
            stringList.add(getKeys().get(i).getValue());
            stringList.add("(" + TF + ")");
            stringList.add("\n");
            stringList.add(stFixation(TF));
            stringList.add("\n\n");

        } else {
            stringList.add(getKeys().get(i).getValue());
            stringList.add("(" + TF + ")" + "\n" + stFixation(TF));
        }

        stringList.add("\n\n###Statistics###\n");
        stringList.add(statisticString(pausesVector, getFinalTime(), pause));
        stringList.add(statisticStringCharsChars(charactersVector, pause));
        stringList.add("\n#########################\n\n");

        return stringList;
    }

    /**
     * Key pauses analysis 
     *
     * @param pause - Time between pauses
     * @return ArrayLis with the pauses values
     * @throws java.lang.Exception - Exception
     */
    public ArrayList<String> pauseAnalysis(Integer pause) throws Exception {

        if (getKeys() == null) {
            return null;
        }

        ArrayList<Integer> pausesVector = new ArrayList<>();
        ArrayList<Integer> charactersVector = new ArrayList<>();
        ArrayList<String> stringList = new ArrayList<>();

        stringList.add(getPath());
        stringList.add("(" + getKeys().get(0).getTime() + ")");
        Integer dif;
        Integer chars = 0;
        int i;

        for (i = 0; i < getKeys().size() - 1; i++) {
            // Calculates the time between the Keys N and N+1
            dif = getKeys().get(i + 1).getTime() - getKeys().get(i).getTime();
            
            // Count the number of chars typed in the segment
            chars += charactersCount(getKeys().get(i).getValue());

            if (dif >= pause) {
                pausesVector.add(dif);
                charactersVector.add(chars);
                chars = 0;
                stringList.add(getKeys().get(i).getValue());
                stringList.add("(" + dif + ")");
            } else {
                stringList.add(getKeys().get(i).getValue());
            }
        }

        /*
         * Checks the last element and calculates the difference between 
         * your time and the stop time
         */
        dif = getFinalTime() - getKeys().get(i).getTime();
        chars += charactersCount(getKeys().get(i).getValue());
        pausesVector.add(dif);

        if (dif >= pause) {
            stringList.add(getKeys().get(i).getValue());
            stringList.add("(" + dif + ")");
        } else {
            stringList.add(getKeys().get(i).getValue());
        }
        stringList.add("\n###Statistics###\n");
        stringList.add(statisticString(pausesVector, getFinalTime(), pause));
        stringList.add(statisticStringCharsChars(charactersVector, pause));
        stringList.add("\n#########################");

        return stringList;
    }

    /*
     * fixation checks during the last segment break.
     */
    private String stFixation(Integer TF) {
        if (getIfix() >= getfixation().size()) {
            return "";
        }
        Integer ac = 0;
        Integer sum = 0;
        Integer decrement = getfixation().get(getIfix());

        while (getIfix() < getfixation().size() && getfixation().get(getIfix()) <= TF) {
            ac++;
            sum += getfixation().get(getIfix()) - decrement;
            decrement = getfixation().get(getIfix());
            setIfix((Integer) (getIfix() + 1));
        }
        
        if(ac > 0){
            return "Fixation Number: " + ac + " // Average Fixation Duration: " + (sum / ac) + " ms // Fixation Duration: " + sum;
        }else{
            return "There was no any fixation in this segment";
        }

    }

    /*
     * Counts the number of characters in a string. 
     * If it be a commando will be counted like 1.
     */
    private static Integer charactersCount(String st) {
        if (st == null) {
            return 0;
        } else if (st.startsWith("[")) {
            return 1;
        } else {
            return st.length();
        }
    }

    /*
     * Calculates the average, standard deviation, min and max characters between pauses.
     * Returns a string with the data.
     */
    private static String statisticStringCharsChars(ArrayList<Integer> v, Integer pause) {
        Statistic statistic = new Statistic<>();
        Double average = statistic.average(v);
        Double standardDeviation = statistic.standardDeviation(v, average);
        Double max = statistic.max(v);
        Double min = statistic.min(v);

        String returnValue = "\nAverage of characters between pauses longer than or equal to " + pause + ": " + format2f(average) + "\n"
                + "Standard deviation of characters between pauses longer than or equal to " + pause + ": " + format2f(standardDeviation) + "\n"
                + "Min Standard deviation of characters between pauses longer than or equal to " + pause + ": " + format2f(min) + "\n"
                + "Max Standard deviation of characters between pauses longer than or equal to " + pause + ": " + format2f(max) + "\n";

        return returnValue;

    }

    /*
     * Calculates the average, standard deviation, min and max characters between pauses.
     * Returns a string with the data.
     */
    private static String statisticString(ArrayList<Integer> v, Integer finalTime, Integer pause) {
        Statistic statistic = new Statistic<>();
        Double average = statistic.average(v);
        Double standardDeviation = statistic.standardDeviation(v, average);
        Double max = statistic.max(v);
        Double min = statistic.min(v);

        String returnValue = "Task duration: " + finalTime + " \n" + ""
                + "Average of pauses longer than or equal to " + pause + ": " + format2f(average) + "\n"
                + "Standard Deviation of pauses longer than or equal to " + pause + ": " + format2f(standardDeviation) + "\n"
                + "Min value of pauses longer than or equal to " + pause + ": " + format2f(min) + "\n"
                + "Max value of pauses longer than or equal to " + pause + ": " + format2f(max) + "\n";

        return returnValue;

    }

    private static String format2f(Number n) {
        return String.format("%.2f", n);
    }

    /**
     * @return the path
     */
    public String getPath() {
        return path;
    }

    /**
     * @param path the path to set
     */
    public void setPath(String path) {
        this.path = path;
    }

    /**
     * @return the fix
     */
    public ArrayList<Integer> getfixation() {
        return fix;
    }

    /**
     * @param fix the fix to set
     */
    public void setfixation(ArrayList<Integer> fix) {
        this.fix = fix;
    }

    /**
     * @return the keys
     */
    public ArrayList<Key> getKeys() {
        return keys;
    }

    /**
     * @param keys the keys to set
     */
    public void setKeys(ArrayList<Key> keys) {
        this.keys = keys;
    }

    /**
     * @return the finalTime
     */
    public Integer getFinalTime() {
        return finalTime;
    }

    /**
     * @param finalTime the finalTime to set
     */
    public void setFinalTime(Integer finalTime) {
        this.finalTime = finalTime;
    }

    /**
     * @return the ifix
     */
    public Integer getIfix() {
        return ifix;
    }

    /**
     * @param ifix the ifix to set
     */
    public void setIfix(Integer ifix) {
        this.ifix = ifix;
    }
}
